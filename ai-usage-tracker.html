<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Usage Tracker - Monitor de Consumo IA</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .session-indicator {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-top: 10px;
            font-weight: bold;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card h3 {
            color: #667eea;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }

        .stat-label {
            color: #999;
            font-size: 0.85em;
            margin-top: 5px;
        }

        .input-section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            color: #667eea;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        input[type="number"] {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1.1em;
            transition: border-color 0.3s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 150px;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #ff4757;
            color: white;
        }

        .btn-danger:hover {
            background: #ff3838;
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background: #27ae60;
        }

        .btn-toggle {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            font-size: 0.95em;
            min-width: auto;
            flex: none;
            width: auto;
        }

        .btn-toggle:hover {
            background: #2980b9;
        }

        .btn-toggle.active {
            background: #2ecc71;
        }

        .input-mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toggle-label {
            font-size: 0.95em;
            color: #666;
        }

        .history-section, .stats-section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .history-section h2, .stats-section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            overflow-x: auto;
            display: block;
        }

        .history-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .history-table th,
        .history-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .history-table tbody tr:hover {
            background: #f8f8ff;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }

        .chart-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
        }

        .chart {
            width: 100%;
            position: relative;
            overflow: visible;
        }

        .chart svg {
            display: block;
            width: 100%;
            height: auto;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            white-space: nowrap;
        }

        .chart-tooltip.active {
            opacity: 1;
        }

        .chart-point {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-point:hover {
            r: 7;
            filter: brightness(1.2);
        }

        .session-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .dashboard {
                grid-template-columns: 1fr;
            }

            .btn-group {
                flex-direction: column;
            }

            button {
                width: 100%;
            }

            .history-table {
                font-size: 0.9em;
            }

            .history-table th,
            .history-table td {
                padding: 10px 5px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .chart-container {
                min-height: 150px;
            }

            .chart svg {
                max-height: 200px;
            }
        }

        .delete-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .delete-btn:hover {
            background: #ff3838;
        }

        .mini-stat {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .mini-stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .mini-stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }

        .edit-dates-section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .edit-dates-section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .session-edit-card {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            margin-bottom: 15px;
        }

        .session-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .session-edit-title {
            color: #667eea;
            font-weight: bold;
            font-size: 1.1em;
        }

        .date-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .date-input-group label {
            margin: 0;
            font-size: 0.9em;
        }

        .date-input-group input[type="datetime-local"] {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.95em;
        }

        .date-input-group input[type="datetime-local"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-update {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
        }

        .btn-update:hover {
            background: #5568d3;
        }

        .prompt-list {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
            font-size: 0.9em;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>AI Usage Tracker</h1>
            <p class="subtitle">Monitor de Consumo de Modelo IA - 8h/d√≠a (4.1‚Ç¨/d√≠a, 0.5‚Ç¨/h)</p>
            <div class="session-indicator" id="sessionIndicator">Sesi√≥n 1 de 2</div>
        </header>

        <div id="alertContainer"></div>

        <div class="dashboard">
            <div class="stat-card">
                <h3>Uso Sesi√≥n Actual (5h)</h3>
                <div class="stat-value" id="totalUsage">0.00%</div>
                <div class="stat-label" style="color: #666; font-size: 0.95em; margin-top: 5px;">
                    Restante: <span id="remainingUsage" style="font-weight: bold; color: #2ecc71;">100.00%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
                </div>
            </div>

            <div class="stat-card">
                <h3>Coste Diario Total</h3>
                <div class="stat-value" id="totalCost">0.00‚Ç¨</div>
                <div class="stat-label">de 4.10‚Ç¨/d√≠a (8h)</div>
            </div>

            <div class="stat-card">
                <h3>Coste Medio/Prompt</h3>
                <div class="stat-value" id="avgCostPerPrompt">0.000‚Ç¨</div>
                <div class="stat-label">todas las sesiones</div>
            </div>

            <div class="stat-card">
                <h3>Total Prompts Hoy</h3>
                <div class="stat-value" id="totalPrompts">0</div>
                <div class="stat-label">todas las sesiones</div>
            </div>

            <div class="stat-card">
                <h3>Uso Medio/Prompt</h3>
                <div class="stat-value" id="avgPerPrompt">0.00%</div>
                <div class="stat-label">sesi√≥n actual</div>
            </div>

            <div class="stat-card">
                <h3>Prompts/Hora</h3>
                <div class="stat-value" id="promptsPerHour">0</div>
                <div class="stat-label">estimados</div>
            </div>

            <div class="stat-card">
                <h3>Minutos/Prompt</h3>
                <div class="stat-value" id="minutesPerPrompt">0</div>
                <div class="stat-label">disponible cada</div>
            </div>

            <div class="stat-card">
                <h3>Prompts Restantes (95%)</h3>
                <div class="stat-value" id="remainingPrompts">0</div>
                <div class="stat-label">en esta sesi√≥n</div>
            </div>

            <div class="stat-card">
                <h3>Fin de Sesi√≥n</h3>
                <div class="stat-value" id="sessionEndTime" style="font-size: 1.5em;">--:--</div>
                <div class="stat-label">hora estimada</div>
            </div>

            <div class="stat-card">
                <h3>Tiempo Restante</h3>
                <div class="stat-value" id="timeRemaining">0h 0m</div>
                <div class="stat-label">de sesi√≥n</div>
            </div>

            <div class="stat-card">
                <h3>Prompts por Hora</h3>
                <div class="stat-value" id="promptsCurrentHour" style="font-size: 1.3em;">0 / 0</div>
                <div class="stat-label">uniforme / ritmo actual</div>
            </div>

            <div class="stat-card">
                <h3>Prompts Proyectadas</h3>
                <div class="stat-value" id="promptsProjected" style="font-size: 1.3em;">0 / 0</div>
                <div class="stat-label">necesarias / al ritmo actual</div>
            </div>
        </div>

        <div class="input-section">
            <h2 style="color: #667eea; margin-bottom: 20px;">Registrar Nuevo Prompt</h2>
            <form id="promptForm">
                <div class="input-mode-toggle">
                    <span class="toggle-label">Modo de entrada:</span>
                    <button type="button" class="btn-toggle" id="toggleModeBtn" onclick="toggleInputMode()">
                        <span id="toggleModeText">% Consumido</span>
                    </button>
                    <span class="toggle-label" id="modeDescription">Introduce el porcentaje consumido</span>
                </div>
                <div class="form-group">
                    <label for="currentUsage" id="usageLabel">Porcentaje de Uso Actual (%):</label>
                    <input
                        type="number"
                        id="currentUsage"
                        step="0.01"
                        min="0"
                        max="100"
                        placeholder="Ej: 15.5"
                        required
                    >
                </div>
                <div class="form-group">
                    <label for="modelType">Tipo de Modelo:</label>
                    <select id="modelType" style="width: 100%; padding: 15px; border: 2px solid #e0e0e0; border-radius: 10px; font-size: 1.1em; background: white; cursor: pointer;">
                        <option value="Sonnet">Claude Sonnet</option>
                        <option value="Haiku">Claude Haiku</option>
                        <option value="Opus">Claude Opus</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button type="submit" class="btn-primary">Registrar Prompt</button>
                    <button type="button" class="btn-secondary" onclick="resetSession()">Nueva Sesi√≥n (5h)</button>
                    <button type="button" class="btn-danger" onclick="endDay()">Acabar el D√≠a</button>
                </div>
            </form>
        </div>

        <div class="history-section">
            <h2>Hist√≥rico de Prompts - Sesi√≥n Actual</h2>
            <div style="overflow-x: auto;">
                <table class="history-table" id="historyTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fecha/Hora</th>
                            <th>Modelo</th>
                            <th>Uso Acumulado</th>
                            <th>Consumo Prompt</th>
                            <th>Coste Prompt</th>
                            <th>Acciones</th>
                        </tr>
                    </thead>
                    <tbody id="historyBody">
                        <tr>
                            <td colspan="7" class="empty-state">
                                <div>
                                    <p style="font-size: 1.2em;">No hay prompts registrados en esta sesi√≥n</p>
                                    <p>Introduce el porcentaje de uso actual para comenzar</p>
                                </div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- SECCI√ìN: Estad√≠sticas del D√≠a Actual -->
        <div class="stats-section" id="todayStatsSection">
            <h2>üìä Estad√≠sticas del D√≠a Actual</h2>
            <div id="todayStatsContent"></div>
        </div>

        <!-- Estad√≠sticas Semanales -->
        <div class="stats-section" id="weeklyStatsSection">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px;">
                <h2 style="margin: 0;">üìà Estad√≠sticas Semanales (√öltimos 7 d√≠as)</h2>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">
                    <button class="btn-success" onclick="document.getElementById('importFileInput').click()" style="min-width: auto; flex: none; background: #3498db;">
                        üì• Importar Datos
                    </button>
                    <button class="btn-success" onclick="exportWeeklyData()" style="min-width: auto; flex: none;">
                        üíæ Exportar Datos
                    </button>
                </div>
            </div>
            <div id="weeklyStatsContent"></div>
        </div>

        <!-- Secci√≥n para Editar Fechas de Sesiones -->
        <div class="edit-dates-section" id="editDatesSection">
            <h2>üìÖ Editar Fechas de Sesiones</h2>
            <p style="color: #666; margin-bottom: 20px;">Modifica las fechas de las sesiones registradas. Los cambios se aplicar√°n a todos los prompts de la sesi√≥n.</p>
            <div id="editDatesContent"></div>
        </div>
    </div>

    <script>
        // Configuraci√≥n: 4.1‚Ç¨/d√≠a para 8h de uso, el uso se mide en sesiones de 5h
        const COST_PER_DAY = 4.1;
        const COST_PER_HOUR = 0.5;
        const HOURS_PER_DAY = 8;
        const USAGE_HOURS = 5;
        const COST_PER_PERCENT = COST_PER_HOUR / 100;

        // Estado actual
        let currentSessionNumber = parseInt(localStorage.getItem('currentSessionNumber')) || 1;
        let currentSessionPrompts = JSON.parse(localStorage.getItem('currentSessionPrompts')) || [];
        let lastUsage = parseFloat(localStorage.getItem('lastUsage')) || 0;
        let dailyCost = parseFloat(localStorage.getItem('dailyCost')) || 0;
        let completedSessions = JSON.parse(localStorage.getItem('completedSessions')) || [];
        let dailyHistory = JSON.parse(localStorage.getItem('dailyHistory')) || [];

        // Modo de entrada: 'consumed' (consumido) o 'remaining' (restante)
        let inputMode = localStorage.getItem('inputMode') || 'consumed';

        function toggleInputMode() {
            inputMode = inputMode === 'consumed' ? 'remaining' : 'consumed';
            localStorage.setItem('inputMode', inputMode);
            updateInputModeUI();
            showAlert(`Modo cambiado a: ${inputMode === 'consumed' ? 'Porcentaje Consumido' : 'Porcentaje Restante'}`, 'success');
        }

        function updateInputModeUI() {
            const toggleBtn = document.getElementById('toggleModeBtn');
            const toggleText = document.getElementById('toggleModeText');
            const modeDescription = document.getElementById('modeDescription');
            const usageLabel = document.getElementById('usageLabel');

            if (inputMode === 'consumed') {
                toggleText.textContent = '% Consumido';
                toggleBtn.classList.remove('active');
                modeDescription.textContent = 'Introduce el porcentaje consumido';
                usageLabel.textContent = 'Porcentaje Consumido (%):';
            } else {
                toggleText.textContent = '% Restante';
                toggleBtn.classList.add('active');
                modeDescription.textContent = 'Introduce el porcentaje restante';
                usageLabel.textContent = 'Porcentaje Restante (%):';
            }
        }

        function showAlert(message, type = 'success') {
            const alertContainer = document.getElementById('alertContainer');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            alertContainer.appendChild(alert);

            setTimeout(() => {
                alert.remove();
            }, 3000);
        }

        function updateDashboard() {
            let allPromptsToday = [...currentSessionPrompts];
            completedSessions.forEach(session => {
                allPromptsToday = allPromptsToday.concat(session.prompts);
            });

            const totalUsageCurrentSession = lastUsage;
            const totalCost = dailyCost;
            const totalPromptsToday = allPromptsToday.length;
            const totalPromptsCurrentSession = currentSessionPrompts.length;

            let avgPerPrompt = 0;
            let avgCostPerPrompt = 0;
            let promptsPerHour = 0;
            let minutesPerPrompt = 0;

            if (totalPromptsCurrentSession > 0) {
                avgPerPrompt = totalUsageCurrentSession / totalPromptsCurrentSession;
                if (avgPerPrompt > 0) {
                    // Basado en 5h (300 min): si uso medio es X%, puedes hacer 100/X prompts en 5h
                    const totalPromptsIn5h = 100 / avgPerPrompt;
                    promptsPerHour = Math.floor(totalPromptsIn5h / 5);
                    minutesPerPrompt = (300 / totalPromptsIn5h).toFixed(1);
                }
            }

            if (totalPromptsToday > 0) {
                avgCostPerPrompt = totalCost / totalPromptsToday;
            }

            // NUEVOS C√ÅLCULOS: Prompts restantes y tiempo de sesi√≥n
            let remainingPrompts = 0;
            let sessionEndTime = '--:--';
            let timeRemaining = '--';
            let promptsPerHourUniform = 0;
            let promptsPerHourAdapted = 0;
            let promptsProjectedNecessary = 0;
            let promptsProjectedAtCurrentRate = 0;

            if (totalPromptsCurrentSession > 0) {
                // 1. Calcular hora de inicio de sesi√≥n (primer prompt - 10 minutos)
                const firstPromptTime = new Date(currentSessionPrompts[0].timestamp);
                const sessionStartTime = new Date(firstPromptTime.getTime() - 10 * 60 * 1000);

                // 2. Calcular hora de fin de sesi√≥n (inicio + 5 horas)
                const sessionEndTimeDate = new Date(sessionStartTime.getTime() + 5 * 60 * 60 * 1000);
                sessionEndTime = sessionEndTimeDate.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

                // 3. Calcular tiempo transcurrido y restante
                const now = new Date();
                const sessionElapsedMs = now - sessionStartTime;
                const sessionElapsedHours = sessionElapsedMs / (60 * 60 * 1000);
                const timeRemainingMs = sessionEndTimeDate - now;

                if (timeRemainingMs > 0) {
                    const hoursRemaining = Math.floor(timeRemainingMs / (60 * 60 * 1000));
                    const minutesRemainingTotal = Math.floor(timeRemainingMs / (60 * 1000));
                    const minutesRemaining = minutesRemainingTotal % 60;
                    timeRemaining = `${hoursRemaining}h ${minutesRemaining}m`;
                    const totalHoursRemaining = timeRemainingMs / (60 * 60 * 1000);

                    // 4. Calcular prompts restantes hasta el 95%
                    const usageRemaining = 95 - totalUsageCurrentSession;
                    // Redondear hacia arriba el uso medio por prompt para ser conservador
                    const avgPerPromptRoundedUp = Math.ceil(avgPerPrompt * 100) / 100;

                    if (avgPerPromptRoundedUp > 0 && usageRemaining > 0) {
                        remainingPrompts = usageRemaining / avgPerPromptRoundedUp;

                        // 5. Calcular prompts por hora - UNIFORME (distribuci√≥n equitativa)
                        // Dividir las prompts restantes entre las horas que quedan de sesi√≥n
                        if (totalHoursRemaining > 0) {
                            promptsPerHourUniform = remainingPrompts / totalHoursRemaining;
                        }

                        // 6. Calcular prompts por hora - ADAPTADO (ritmo actual)
                        // Basado en cu√°ntas prompts has hecho por hora hasta ahora
                        if (sessionElapsedHours > 0) {
                            const currentRatePerHour = totalPromptsCurrentSession / sessionElapsedHours;

                            // El adaptado es el ritmo actual, pero limitado a no exceder las prompts restantes
                            // Si al ritmo actual te pasas del 95%, ajustamos al ritmo sostenible
                            const maxSustainableRate = totalHoursRemaining > 0 ? remainingPrompts / totalHoursRemaining : 0;
                            promptsPerHourAdapted = Math.min(currentRatePerHour, maxSustainableRate);

                            // 7. Calcular prompts proyectadas
                            // Necesarias: las que quedan para llegar al 95%
                            promptsProjectedNecessary = remainingPrompts;
                            // Al ritmo actual: cu√°ntas har√°s si sigues as√≠ en el tiempo restante
                            promptsProjectedAtCurrentRate = currentRatePerHour * totalHoursRemaining;
                        }
                    }
                } else {
                    timeRemaining = '¬°Sesi√≥n finalizada!';
                }
            }

            document.getElementById('totalUsage').textContent = totalUsageCurrentSession.toFixed(2) + '%';
            document.getElementById('remainingUsage').textContent = (100 - totalUsageCurrentSession).toFixed(2) + '%';
            document.getElementById('totalCost').textContent = totalCost.toFixed(2) + '‚Ç¨';
            document.getElementById('avgCostPerPrompt').textContent = avgCostPerPrompt.toFixed(3) + '‚Ç¨';
            document.getElementById('totalPrompts').textContent = totalPromptsToday;
            document.getElementById('avgPerPrompt').textContent = avgPerPrompt.toFixed(2) + '%';
            document.getElementById('promptsPerHour').textContent = promptsPerHour;
            document.getElementById('minutesPerPrompt').textContent = minutesPerPrompt;

            // Actualizar nuevos campos
            document.getElementById('remainingPrompts').textContent = remainingPrompts.toFixed(2);
            document.getElementById('sessionEndTime').textContent = sessionEndTime;
            document.getElementById('timeRemaining').textContent = timeRemaining;
            document.getElementById('promptsCurrentHour').textContent = `${promptsPerHourUniform.toFixed(2)} / ${promptsPerHourAdapted.toFixed(2)}`;
            document.getElementById('promptsProjected').textContent = `${promptsProjectedNecessary.toFixed(2)} / ${promptsProjectedAtCurrentRate.toFixed(2)}`;

            document.getElementById('sessionIndicator').textContent = `Sesi√≥n ${currentSessionNumber} de 2`;

            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = Math.min(totalUsageCurrentSession, 100) + '%';
            progressBar.textContent = totalUsageCurrentSession.toFixed(1) + '%';

            if (totalUsageCurrentSession > 90) {
                progressBar.style.background = 'linear-gradient(90deg, #ff4757 0%, #ff3838 100%)';
            } else if (totalUsageCurrentSession > 70) {
                progressBar.style.background = 'linear-gradient(90deg, #ffa502 0%, #ff6348 100%)';
            } else {
                progressBar.style.background = 'linear-gradient(90deg, #667eea 0%, #764ba2 100%)';
            }
        }

        function updateHistoryTable() {
            const tbody = document.getElementById('historyBody');

            if (currentSessionPrompts.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" class="empty-state">
                            <div>
                                <p style="font-size: 1.2em;">No hay prompts registrados en esta sesi√≥n</p>
                                <p>Introduce el porcentaje de uso actual para comenzar</p>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = currentSessionPrompts.map((prompt, index) => {
                const modelBadgeColor = prompt.model === 'Sonnet' ? '#667eea' :
                                       prompt.model === 'Haiku' ? '#2ecc71' :
                                       prompt.model === 'Opus' ? '#ff6348' : '#999';
                const modelDisplay = prompt.model || 'N/A';

                return `
                <tr>
                    <td>${index + 1}</td>
                    <td>${new Date(prompt.timestamp).toLocaleString('es-ES')}</td>
                    <td><span style="background: ${modelBadgeColor}; color: white; padding: 4px 10px; border-radius: 5px; font-size: 0.85em; font-weight: bold;">${modelDisplay}</span></td>
                    <td><strong>${prompt.usage.toFixed(2)}%</strong></td>
                    <td>${prompt.consumed.toFixed(2)}%</td>
                    <td>${prompt.cost.toFixed(3)}‚Ç¨</td>
                    <td>
                        <button class="delete-btn" onclick="deletePrompt(${index})">Eliminar</button>
                    </td>
                </tr>
                `;
            }).join('');
        }

        function createLineChart(data, labels, title, color = '#667eea', suffix = '') {
            if (!data || data.length === 0) return '<p class="empty-state">No hay datos suficientes</p>';

            const chartId = 'chart-' + Math.random().toString(36).substr(2, 9);
            const width = 600;
            const height = 250;
            const padding = 60; // Aumentado para dar espacio a las etiquetas

            const maxValue = Math.max(...data, 1);
            const minValue = Math.min(...data, 0);
            const range = maxValue - minValue || 1;

            // Calcular posiciones de los puntos
            const points = data.map((value, index) => {
                const x = padding + (index / (data.length - 1 || 1)) * (width - 2 * padding);
                const y = height - padding - ((value - minValue) / range) * (height - 2 * padding);
                return `${x},${y}`;
            }).join(' ');

            // Puntos interactivos
            const circles = data.map((value, index) => {
                const x = padding + (index / (data.length - 1 || 1)) * (width - 2 * padding);
                const y = height - padding - ((value - minValue) / range) * (height - 2 * padding);
                const displayValue = value.toFixed(2) + suffix;
                const label = labels && labels[index] ? labels[index] : `Punto ${index + 1}`;
                return `<circle class="chart-point" cx="${x}" cy="${y}" r="5" fill="${color}"
                    onmouseover="showTooltip(event, '${label}: ${displayValue}')"
                    onmouseout="hideTooltip()" />`;
            }).join('');

            // Eje Y - etiquetas
            const yAxisLabels = [];
            const numYTicks = 5;
            for (let i = 0; i <= numYTicks; i++) {
                const value = minValue + (range * i / numYTicks);
                const y = height - padding - (i / numYTicks) * (height - 2 * padding);
                yAxisLabels.push(`
                    <text x="${padding - 10}" y="${y}" text-anchor="end" font-size="10" fill="#666" dominant-baseline="middle">
                        ${value.toFixed(1)}${suffix}
                    </text>
                    <line x1="${padding - 5}" y1="${y}" x2="${padding}" y2="${y}" stroke="#999" stroke-width="1" />
                `);
            }

            // Eje X - etiquetas (mostramos algunas etiquetas seleccionadas)
            const xAxisLabels = [];
            const numXTicks = Math.min(data.length, 5); // M√°ximo 5 etiquetas
            const xStep = Math.floor((data.length - 1) / (numXTicks - 1 || 1)) || 1;
            for (let i = 0; i < data.length; i += xStep) {
                const x = padding + (i / (data.length - 1 || 1)) * (width - 2 * padding);
                const label = labels && labels[i] ? labels[i] : i + 1;
                xAxisLabels.push(`
                    <text x="${x}" y="${height - padding + 20}" text-anchor="middle" font-size="10" fill="#666">
                        ${label}
                    </text>
                    <line x1="${x}" y1="${height - padding}" x2="${x}" y2="${height - padding + 5}" stroke="#999" stroke-width="1" />
                `);
            }

            return `
                <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: auto; max-height: 200px;">
                    <!-- Ejes -->
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#999" stroke-width="2" />
                    <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" stroke="#999" stroke-width="2" />

                    <!-- Etiquetas eje Y -->
                    ${yAxisLabels.join('')}

                    <!-- Etiquetas eje X -->
                    ${xAxisLabels.join('')}

                    <!-- L√≠nea de datos -->
                    <polyline points="${points}" fill="none" stroke="${color}" stroke-width="2.5" />

                    <!-- Puntos interactivos -->
                    ${circles}
                </svg>
            `;
        }

        function showTooltip(event, text) {
            const tooltip = document.querySelector('.chart-tooltip');
            if (!tooltip) {
                const newTooltip = document.createElement('div');
                newTooltip.className = 'chart-tooltip';
                newTooltip.textContent = text;
                document.body.appendChild(newTooltip);

                newTooltip.style.left = (event.pageX + 10) + 'px';
                newTooltip.style.top = (event.pageY - 30) + 'px';
                setTimeout(() => newTooltip.classList.add('active'), 10);
            } else {
                tooltip.textContent = text;
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 30) + 'px';
                tooltip.classList.add('active');
            }
        }

        function hideTooltip() {
            const tooltip = document.querySelector('.chart-tooltip');
            if (tooltip) {
                tooltip.classList.remove('active');
            }
        }

        function getModelStats(prompts) {
            const stats = {
                Sonnet: { count: 0, totalCost: 0, totalConsumed: 0 },
                Haiku: { count: 0, totalCost: 0, totalConsumed: 0 },
                Opus: { count: 0, totalCost: 0, totalConsumed: 0 }
            };

            prompts.forEach(prompt => {
                const model = prompt.model || 'Sonnet'; // Default para prompts antiguos
                if (stats[model]) {
                    stats[model].count++;
                    stats[model].totalCost += prompt.cost;
                    stats[model].totalConsumed += prompt.consumed;
                }
            });

            return stats;
        }

        function createBarChart(data, title, suffix = '') {
            if (!data || Object.keys(data).length === 0) return '<p class="empty-state">No hay datos suficientes</p>';

            const width = 500;
            const height = 250;
            const padding = 80;

            const models = ['Sonnet', 'Haiku', 'Opus'];
            const colors = { Sonnet: '#667eea', Haiku: '#2ecc71', Opus: '#ff6348' };
            const values = models.map(m => data[m] || 0);
            const maxValue = Math.max(...values, 1);

            const barWidth = (width - 2 * padding) / models.length - 20;
            const barSpacing = (width - 2 * padding) / models.length;

            const bars = models.map((model, index) => {
                const value = values[index];
                const barHeight = (value / maxValue) * (height - 2 * padding);
                const x = padding + index * barSpacing + 10;
                const y = height - padding - barHeight;
                const displayValue = value.toFixed(suffix === '‚Ç¨' ? 3 : suffix === '%' ? 2 : 0) + suffix;

                return `
                    <rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${colors[model]}" rx="5"
                        onmouseover="showTooltip(event, '${model}: ${displayValue}')"
                        onmouseout="hideTooltip()" style="cursor: pointer;" />
                    <text x="${x + barWidth / 2}" y="${height - padding + 20}" text-anchor="middle" font-size="12" fill="#333" font-weight="bold">
                        ${model}
                    </text>
                    <text x="${x + barWidth / 2}" y="${y - 10}" text-anchor="middle" font-size="11" fill="#333" font-weight="bold">
                        ${displayValue}
                    </text>
                `;
            }).join('');

            // Eje Y - etiquetas
            const yAxisLabels = [];
            const numYTicks = 5;
            for (let i = 0; i <= numYTicks; i++) {
                const value = (maxValue * i / numYTicks);
                const y = height - padding - (i / numYTicks) * (height - 2 * padding);
                yAxisLabels.push(`
                    <text x="${padding - 10}" y="${y}" text-anchor="end" font-size="10" fill="#666" dominant-baseline="middle">
                        ${value.toFixed(suffix === '‚Ç¨' ? 2 : suffix === '%' ? 1 : 0)}${suffix}
                    </text>
                    <line x1="${padding - 5}" y1="${y}" x2="${padding}" y2="${y}" stroke="#999" stroke-width="1" />
                `);
            }

            return `
                <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: auto; max-height: 200px;">
                    <!-- Ejes -->
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#999" stroke-width="2" />
                    <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" stroke="#999" stroke-width="2" />

                    <!-- Etiquetas eje Y -->
                    ${yAxisLabels.join('')}

                    <!-- Barras -->
                    ${bars}
                </svg>
            `;
        }

        function updateTodayStats() {
            const content = document.getElementById('todayStatsContent');

            let allPromptsToday = [...currentSessionPrompts];
            completedSessions.forEach(session => {
                allPromptsToday = allPromptsToday.concat(session.prompts);
            });

            if (allPromptsToday.length === 0) {
                content.innerHTML = '<div class="empty-state"><p>No hay prompts registrados hoy. Comienza a registrar para ver las estad√≠sticas.</p></div>';
                return;
            }

            // Calcular estad√≠sticas del d√≠a
            const totalUsageToday = completedSessions.reduce((sum, s) => sum + s.totalUsage, 0) + lastUsage;
            const totalCostToday = dailyCost;
            const totalPromptsToday = allPromptsToday.length;
            const avgUsagePerPrompt = totalUsageToday / totalPromptsToday;
            const avgCostPerPrompt = totalCostToday / totalPromptsToday;
            // Basado en 5h (300 min): si uso medio es X%, puedes hacer 100/X prompts en 5h
            const totalPromptsIn5h = avgUsagePerPrompt > 0 ? 100 / avgUsagePerPrompt : 0;
            const promptsPerHour = avgUsagePerPrompt > 0 ? Math.floor(totalPromptsIn5h / 5) : 0;
            const minutesPerPrompt = totalPromptsIn5h > 0 ? (300 / totalPromptsIn5h).toFixed(1) : 0;

            // Datos para gr√°ficos (evoluci√≥n temporal)
            const usageOverTime = [];
            const costOverTime = [];
            const timeLabels = [];
            let cumulativeUsage = 0;
            let cumulativeCost = 0;

            allPromptsToday.forEach((prompt, index) => {
                cumulativeUsage += prompt.consumed;
                cumulativeCost += prompt.cost;
                usageOverTime.push(cumulativeUsage);
                costOverTime.push(cumulativeCost);
                timeLabels.push(`Prompt ${index + 1}`);
            });

            // Obtener estad√≠sticas por modelo
            const modelStats = getModelStats(allPromptsToday);

            let html = `
                <div class="stats-grid">
                    <div class="mini-stat">
                        <div class="mini-stat-label">Uso Total Hoy</div>
                        <div class="mini-stat-value">${totalUsageToday.toFixed(2)}%</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Coste Total Hoy</div>
                        <div class="mini-stat-value">${totalCostToday.toFixed(2)}‚Ç¨</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Total Prompts</div>
                        <div class="mini-stat-value">${totalPromptsToday}</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">% Medio/Prompt</div>
                        <div class="mini-stat-value">${avgUsagePerPrompt.toFixed(2)}%</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Coste Medio/Prompt</div>
                        <div class="mini-stat-value">${avgCostPerPrompt.toFixed(3)}‚Ç¨</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Prompts/Hora</div>
                        <div class="mini-stat-value">${promptsPerHour}</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Minutos/Prompt</div>
                        <div class="mini-stat-value">${minutesPerPrompt} min</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Sesiones Hoy</div>
                        <div class="mini-stat-value">${completedSessions.length + 1}</div>
                    </div>
                </div>

                <h3 style="color: #667eea; margin: 30px 0 15px 0;">ü§ñ Uso por Tipo de Modelo</h3>
                <div class="stats-grid">
                    <div class="mini-stat" style="border-left: 3px solid #667eea;">
                        <div class="mini-stat-label">Prompts Sonnet</div>
                        <div class="mini-stat-value">${modelStats.Sonnet.count}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">${modelStats.Sonnet.totalCost.toFixed(3)}‚Ç¨ | ${modelStats.Sonnet.totalConsumed.toFixed(2)}%</div>
                    </div>
                    <div class="mini-stat" style="border-left: 3px solid #2ecc71;">
                        <div class="mini-stat-label">Prompts Haiku</div>
                        <div class="mini-stat-value">${modelStats.Haiku.count}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">${modelStats.Haiku.totalCost.toFixed(3)}‚Ç¨ | ${modelStats.Haiku.totalConsumed.toFixed(2)}%</div>
                    </div>
                    <div class="mini-stat" style="border-left: 3px solid #ff6348;">
                        <div class="mini-stat-label">Prompts Opus</div>
                        <div class="mini-stat-value">${modelStats.Opus.count}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">${modelStats.Opus.totalCost.toFixed(3)}‚Ç¨ | ${modelStats.Opus.totalConsumed.toFixed(2)}%</div>
                    </div>
                </div>

                <h3 style="color: #667eea; margin: 30px 0 15px 0;">üìä Distribuci√≥n por Modelo (Hover para detalles)</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-top: 20px;">
                    <div class="chart-container">
                        <div class="chart-title">Uso Total (%) por Modelo</div>
                        <div class="chart">${createBarChart({ Sonnet: modelStats.Sonnet.totalConsumed, Haiku: modelStats.Haiku.totalConsumed, Opus: modelStats.Opus.totalConsumed }, 'Uso', '%')}</div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Coste Total (‚Ç¨) por Modelo</div>
                        <div class="chart">${createBarChart({ Sonnet: modelStats.Sonnet.totalCost, Haiku: modelStats.Haiku.totalCost, Opus: modelStats.Opus.totalCost }, 'Coste', '‚Ç¨')}</div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">N√∫mero de Prompts por Modelo</div>
                        <div class="chart">${createBarChart({ Sonnet: modelStats.Sonnet.count, Haiku: modelStats.Haiku.count, Opus: modelStats.Opus.count }, 'Prompts', '')}</div>
                    </div>
                </div>

                <h3 style="color: #667eea; margin: 30px 0 15px 0;">üìà Gr√°ficos de Evoluci√≥n (Hover para detalles)</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px;">
                    <div class="chart-container">
                        <div class="chart-title">Evoluci√≥n de Uso (%) - Hover para detalles</div>
                        <div class="chart">${createLineChart(usageOverTime, timeLabels, 'Uso', '#667eea', '%')}</div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Evoluci√≥n de Coste (‚Ç¨) - Hover para detalles</div>
                        <div class="chart">${createLineChart(costOverTime, timeLabels, 'Coste', '#2ecc71', '‚Ç¨')}</div>
                    </div>
                </div>
            `;

            content.innerHTML = html;
        }

        function updateWeeklyStats() {
            const content = document.getElementById('weeklyStatsContent');

            // Verificar si hay datos del d√≠a actual
            let allPromptsToday = [...currentSessionPrompts];
            completedSessions.forEach(session => {
                allPromptsToday = allPromptsToday.concat(session.prompts);
            });

            const hasTodayData = allPromptsToday.length > 0;

            // Si no hay historial NI datos de hoy, mostrar mensaje
            if (dailyHistory.length === 0 && !hasTodayData) {
                content.innerHTML = `
                    <div class="empty-state">
                        <p style="font-size: 1.2em;">üìÖ A√∫n no hay historial semanal</p>
                        <p>Registra algunos prompts para comenzar a ver las estad√≠sticas.</p>
                        <p style="margin-top: 10px; color: #667eea;">Los datos del d√≠a actual aparecer√°n aqu√≠ autom√°ticamente.</p>
                    </div>
                `;
                return;
            }

            // Crear array combinado: historial + d√≠a actual (si hay datos)
            let allDays = [...dailyHistory];

            if (hasTodayData) {
                // Crear objeto del d√≠a actual para incluirlo en las estad√≠sticas
                let allSessionsToday = [...completedSessions];
                if (currentSessionPrompts.length > 0) {
                    allSessionsToday.push({
                        sessionNumber: currentSessionNumber,
                        totalUsage: lastUsage,
                        prompts: currentSessionPrompts
                    });
                }

                const totalUsageToday = allSessionsToday.reduce((sum, s) => sum + s.totalUsage, 0);

                const todayData = {
                    date: new Date().toISOString().split('T')[0],
                    totalCost: dailyCost,
                    totalPrompts: allPromptsToday.length,
                    avgCostPerPrompt: allPromptsToday.length > 0 ? dailyCost / allPromptsToday.length : 0,
                    sessions: allSessionsToday,
                    isToday: true // Marcador para identificarlo
                };

                // Agregar al inicio (d√≠a m√°s reciente)
                allDays.unshift(todayData);
            }

            // Calcular estad√≠sticas semanales (usando allDays que incluye hoy)
            const totalWeeklyCost = allDays.reduce((sum, day) => sum + day.totalCost, 0);
            const totalWeeklyPrompts = allDays.reduce((sum, day) => sum + day.totalPrompts, 0);
            const avgDailyCost = totalWeeklyCost / allDays.length;
            const avgDailyPrompts = totalWeeklyPrompts / allDays.length;

            // Calcular promedios
            let totalAvgUsagePerPrompt = 0;
            let totalPromptsPerHour = 0;
            let totalMinutesPerPrompt = 0;
            let daysWithData = 0;

            allDays.forEach(day => {
                if (day.totalPrompts > 0) {
                    const totalUsageDay = day.sessions.reduce((sum, s) => sum + s.totalUsage, 0);
                    const avgUsage = totalUsageDay / day.totalPrompts;
                    totalAvgUsagePerPrompt += avgUsage;

                    if (avgUsage > 0) {
                        // Basado en 5h (300 min): si uso medio es X%, puedes hacer 100/X prompts en 5h
                        const totalPromptsIn5h = 100 / avgUsage;
                        const pph = totalPromptsIn5h / 5;
                        totalPromptsPerHour += pph;
                        totalMinutesPerPrompt += (300 / totalPromptsIn5h);
                    }
                    daysWithData++;
                }
            });

            const weeklyAvgUsagePerPrompt = daysWithData > 0 ? totalAvgUsagePerPrompt / daysWithData : 0;
            const weeklyAvgPromptsPerHour = daysWithData > 0 ? totalPromptsPerHour / daysWithData : 0;
            const weeklyAvgMinutesPerPrompt = daysWithData > 0 ? totalMinutesPerPrompt / daysWithData : 0;

            // Datos para gr√°ficos semanales
            const dailyCosts = allDays.map(d => d.totalCost).reverse();
            const dailyPrompts = allDays.map(d => d.totalPrompts).reverse();
            const dailyAvgCost = allDays.map(d => d.avgCostPerPrompt).reverse();
            const dailyAvgUsage = allDays.map(d => {
                const totalUsage = d.sessions.reduce((sum, s) => sum + s.totalUsage, 0);
                return d.totalPrompts > 0 ? totalUsage / d.totalPrompts : 0;
            }).reverse();

            const dayLabels = allDays.map((d, i) => {
                const date = new Date(d.date);
                const label = date.toLocaleDateString('es-ES', { day: 'numeric', month: 'short' });
                return d.isToday ? 'Hoy' : label;
            }).reverse();

            // Calcular estad√≠sticas por modelo para toda la semana
            let allWeeklyPrompts = [];
            allDays.forEach(day => {
                day.sessions.forEach(session => {
                    allWeeklyPrompts = allWeeklyPrompts.concat(session.prompts);
                });
            });
            const weeklyModelStats = getModelStats(allWeeklyPrompts);

            let html = `
                <div class="stats-grid">
                    <div class="mini-stat">
                        <div class="mini-stat-label">Coste Total Semanal</div>
                        <div class="mini-stat-value">${totalWeeklyCost.toFixed(2)}‚Ç¨</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Prompts Totales</div>
                        <div class="mini-stat-value">${totalWeeklyPrompts}</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Coste Medio/D√≠a</div>
                        <div class="mini-stat-value">${avgDailyCost.toFixed(2)}‚Ç¨</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Prompts Medio/D√≠a</div>
                        <div class="mini-stat-value">${avgDailyPrompts.toFixed(1)}</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">% Medio/Prompt</div>
                        <div class="mini-stat-value">${weeklyAvgUsagePerPrompt.toFixed(2)}%</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Prompts/Hora Promedio</div>
                        <div class="mini-stat-value">${weeklyAvgPromptsPerHour.toFixed(1)}</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">Minutos/Prompt Promedio</div>
                        <div class="mini-stat-value">${weeklyAvgMinutesPerPrompt.toFixed(1)} min</div>
                    </div>
                    <div class="mini-stat">
                        <div class="mini-stat-label">D√≠as Registrados</div>
                        <div class="mini-stat-value">${allDays.length}</div>
                    </div>
                </div>

                <h3 style="color: #667eea; margin: 30px 0 15px 0;">ü§ñ Uso Semanal por Tipo de Modelo</h3>
                <div class="stats-grid">
                    <div class="mini-stat" style="border-left: 3px solid #667eea;">
                        <div class="mini-stat-label">Prompts Sonnet</div>
                        <div class="mini-stat-value">${weeklyModelStats.Sonnet.count}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">${weeklyModelStats.Sonnet.totalCost.toFixed(3)}‚Ç¨ | ${weeklyModelStats.Sonnet.totalConsumed.toFixed(2)}%</div>
                    </div>
                    <div class="mini-stat" style="border-left: 3px solid #2ecc71;">
                        <div class="mini-stat-label">Prompts Haiku</div>
                        <div class="mini-stat-value">${weeklyModelStats.Haiku.count}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">${weeklyModelStats.Haiku.totalCost.toFixed(3)}‚Ç¨ | ${weeklyModelStats.Haiku.totalConsumed.toFixed(2)}%</div>
                    </div>
                    <div class="mini-stat" style="border-left: 3px solid #ff6348;">
                        <div class="mini-stat-label">Prompts Opus</div>
                        <div class="mini-stat-value">${weeklyModelStats.Opus.count}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">${weeklyModelStats.Opus.totalCost.toFixed(3)}‚Ç¨ | ${weeklyModelStats.Opus.totalConsumed.toFixed(2)}%</div>
                    </div>
                </div>

                <h3 style="color: #667eea; margin: 30px 0 15px 0;">üìä Distribuci√≥n Semanal por Modelo (Hover para detalles)</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-top: 20px;">
                    <div class="chart-container">
                        <div class="chart-title">Uso Total Semanal (%) por Modelo</div>
                        <div class="chart">${createBarChart({ Sonnet: weeklyModelStats.Sonnet.totalConsumed, Haiku: weeklyModelStats.Haiku.totalConsumed, Opus: weeklyModelStats.Opus.totalConsumed }, 'Uso', '%')}</div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Coste Total Semanal (‚Ç¨) por Modelo</div>
                        <div class="chart">${createBarChart({ Sonnet: weeklyModelStats.Sonnet.totalCost, Haiku: weeklyModelStats.Haiku.totalCost, Opus: weeklyModelStats.Opus.totalCost }, 'Coste', '‚Ç¨')}</div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Prompts Totales Semanales por Modelo</div>
                        <div class="chart">${createBarChart({ Sonnet: weeklyModelStats.Sonnet.count, Haiku: weeklyModelStats.Haiku.count, Opus: weeklyModelStats.Opus.count }, 'Prompts', '')}</div>
                    </div>
                </div>

                <h3 style="color: #667eea; margin: 30px 0 15px 0;">üìà Gr√°ficos de Evoluci√≥n (Hover para detalles)</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px;">
                    <div class="chart-container">
                        <div class="chart-title">Evoluci√≥n Coste Diario (‚Ç¨)</div>
                        <div class="chart">${createLineChart(dailyCosts, dayLabels, 'Coste', '#667eea', '‚Ç¨')}</div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Evoluci√≥n Prompts Diarios</div>
                        <div class="chart">${createLineChart(dailyPrompts, dayLabels, 'Prompts', '#2ecc71', '')}</div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Evoluci√≥n % Medio por Prompt</div>
                        <div class="chart">${createLineChart(dailyAvgUsage, dayLabels, 'Uso %', '#ffa502', '%')}</div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Evoluci√≥n Coste Medio/Prompt (‚Ç¨)</div>
                        <div class="chart">${createLineChart(dailyAvgCost, dayLabels, 'Coste', '#ff6348', '‚Ç¨')}</div>
                    </div>
                </div>

                <h3 style="color: #667eea; margin: 30px 0 15px 0;">üìÖ Desglose por D√≠a</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
            `;

            allDays.forEach(day => {
                const date = new Date(day.date);
                const dayName = day.isToday ? 'üîµ HOY' : date.toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                const totalUsageDay = day.sessions.reduce((sum, s) => sum + s.totalUsage, 0);
                const avgUsageDay = day.totalPrompts > 0 ? totalUsageDay / day.totalPrompts : 0;
                const borderColor = day.isToday ? '#2ecc71' : '#667eea';
                const bgColor = day.isToday ? '#e8f8f0' : '#f8f9ff';

                html += `
                    <div style="background: ${bgColor}; padding: 20px; border-radius: 10px; border-left: 4px solid ${borderColor};">
                        <h4 style="color: ${borderColor}; margin-bottom: 10px;">${dayName} <span class="session-badge">${day.sessions.length} sesiones</span></h4>
                        <div style="display: flex; justify-content: space-between; margin: 5px 0; color: #666;">
                            <span>Coste Total:</span>
                            <strong style="color: #333;">${day.totalCost.toFixed(2)}‚Ç¨</strong>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin: 5px 0; color: #666;">
                            <span>Total Prompts:</span>
                            <strong style="color: #333;">${day.totalPrompts}</strong>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin: 5px 0; color: #666;">
                            <span>Coste Medio/Prompt:</span>
                            <strong style="color: #333;">${day.avgCostPerPrompt.toFixed(3)}‚Ç¨</strong>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin: 5px 0; color: #666;">
                            <span>% Medio/Prompt:</span>
                            <strong style="color: #333;">${avgUsageDay.toFixed(2)}%</strong>
                        </div>
                `;

                day.sessions.forEach(session => {
                    html += `
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.9em;">
                                <span><strong>Sesi√≥n ${session.sessionNumber}:</strong></span>
                                <span>${session.prompts.length} prompts</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.9em; color: #666;">
                                <span>Uso Total:</span>
                                <strong style="color: #333;">${session.totalUsage.toFixed(2)}%</strong>
                            </div>
                        </div>
                    `;
                });

                html += `</div>`;
            });

            html += '</div>';
            content.innerHTML = html;
        }

        function updateEditDatesSection() {
            const content = document.getElementById('editDatesContent');

            // Recolectar todas las sesiones editables
            let allEditableSessions = [];

            // 1. Sesiones del historial diario
            dailyHistory.forEach((day, dayIndex) => {
                day.sessions.forEach((session, sessionIndex) => {
                    allEditableSessions.push({
                        type: 'history',
                        dayIndex: dayIndex,
                        sessionIndex: sessionIndex,
                        date: day.date,
                        session: session
                    });
                });
            });

            // 2. Sesiones completadas del d√≠a actual
            completedSessions.forEach((session, sessionIndex) => {
                allEditableSessions.push({
                    type: 'completed',
                    sessionIndex: sessionIndex,
                    date: new Date().toISOString().split('T')[0],
                    session: session
                });
            });

            // 3. Sesi√≥n actual (si tiene prompts)
            if (currentSessionPrompts.length > 0) {
                allEditableSessions.push({
                    type: 'current',
                    date: new Date().toISOString().split('T')[0],
                    session: {
                        sessionNumber: currentSessionNumber,
                        prompts: currentSessionPrompts,
                        totalUsage: lastUsage
                    }
                });
            }

            // Si no hay sesiones para editar
            if (allEditableSessions.length === 0) {
                content.innerHTML = '<div class="empty-state"><p>No hay sesiones registradas para editar</p></div>';
                return;
            }

            // Renderizar las sesiones editables
            let html = '';

            allEditableSessions.forEach((item, index) => {
                const session = item.session;
                const firstPromptDate = new Date(session.prompts[0].timestamp);
                const lastPromptDate = new Date(session.prompts[session.prompts.length - 1].timestamp);

                // Formatear fecha para el input datetime-local (YYYY-MM-DDTHH:MM)
                const formatDateForInput = (date) => {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    return `${year}-${month}-${day}T${hours}:${minutes}`;
                };

                const dateInputValue = formatDateForInput(firstPromptDate);

                let sessionLabel = '';
                if (item.type === 'history') {
                    sessionLabel = `Historial - ${new Date(item.date).toLocaleDateString('es-ES')} - Sesi√≥n ${session.sessionNumber}`;
                } else if (item.type === 'completed') {
                    sessionLabel = `Hoy (Completada) - Sesi√≥n ${session.sessionNumber}`;
                } else {
                    sessionLabel = `Hoy (Actual) - Sesi√≥n ${session.sessionNumber}`;
                }

                html += `
                    <div class="session-edit-card">
                        <div class="session-edit-header">
                            <div class="session-edit-title">${sessionLabel}</div>
                            <div class="date-input-group">
                                <label>Nueva fecha:</label>
                                <input
                                    type="datetime-local"
                                    id="dateInput_${index}"
                                    value="${dateInputValue}"
                                >
                                <button class="btn-update" onclick="updateSessionDate(${index}, '${item.type}', ${item.dayIndex || 'null'}, ${item.sessionIndex || 'null'})">
                                    Actualizar
                                </button>
                            </div>
                        </div>
                        <div class="prompt-list">
                            <strong>${session.prompts.length} prompts</strong>
                            | Uso total: ${session.totalUsage.toFixed(2)}%
                            | Periodo: ${firstPromptDate.toLocaleString('es-ES')} - ${lastPromptDate.toLocaleString('es-ES')}
                        </div>
                    </div>
                `;
            });

            content.innerHTML = html;
        }

        function updateSessionDate(index, type, dayIndex, sessionIndex) {
            const dateInput = document.getElementById(`dateInput_${index}`);
            const newDateStr = dateInput.value;

            if (!newDateStr) {
                showAlert('Por favor, selecciona una fecha v√°lida', 'warning');
                return;
            }

            const newDate = new Date(newDateStr);
            const newDateOnly = newDate.toISOString().split('T')[0];

            // Funci√≥n auxiliar para actualizar timestamps de una sesi√≥n
            const updateSessionTimestamps = (session, baseDate) => {
                session.prompts.forEach((prompt, i) => {
                    const originalDate = new Date(prompt.timestamp);
                    const updatedDate = new Date(baseDate);

                    // Mantener el offset de tiempo relativo entre prompts
                    if (i > 0) {
                        const prevOriginalDate = new Date(session.prompts[0].timestamp);
                        const timeDiff = originalDate - prevOriginalDate;
                        updatedDate.setTime(baseDate.getTime() + timeDiff);
                    }

                    prompt.timestamp = updatedDate.toISOString();
                });

                // Actualizar startTime y endTime si existen
                if (session.startTime) {
                    session.startTime = session.prompts[0].timestamp;
                }
                if (session.endTime) {
                    session.endTime = session.prompts[session.prompts.length - 1].timestamp;
                }

                return session;
            };

            // Actualizar seg√∫n el tipo de sesi√≥n
            if (type === 'history') {
                const day = dailyHistory[dayIndex];
                const session = day.sessions[sessionIndex];

                // Actualizar la sesi√≥n
                updateSessionTimestamps(session, newDate);

                // Si la fecha cambi√≥ a otro d√≠a, mover la sesi√≥n
                if (newDateOnly !== day.date) {
                    // Buscar si ya existe un d√≠a con esa fecha
                    let targetDayIndex = dailyHistory.findIndex(d => d.date === newDateOnly);

                    if (targetDayIndex === -1) {
                        // Crear nuevo d√≠a
                        const newDay = {
                            date: newDateOnly,
                            totalCost: session.prompts.reduce((sum, p) => sum + p.cost, 0),
                            totalPrompts: session.prompts.length,
                            avgCostPerPrompt: session.prompts.reduce((sum, p) => sum + p.cost, 0) / session.prompts.length,
                            sessions: [session]
                        };
                        dailyHistory.unshift(newDay);
                        if (dailyHistory.length > 7) {
                            dailyHistory = dailyHistory.slice(0, 7);
                        }
                    } else {
                        // Agregar a d√≠a existente
                        dailyHistory[targetDayIndex].sessions.push(session);
                        // Recalcular totales
                        let allPrompts = [];
                        dailyHistory[targetDayIndex].sessions.forEach(s => {
                            allPrompts = allPrompts.concat(s.prompts);
                        });
                        dailyHistory[targetDayIndex].totalCost = allPrompts.reduce((sum, p) => sum + p.cost, 0);
                        dailyHistory[targetDayIndex].totalPrompts = allPrompts.length;
                        dailyHistory[targetDayIndex].avgCostPerPrompt = dailyHistory[targetDayIndex].totalCost / allPrompts.length;
                    }

                    // Eliminar del d√≠a original
                    day.sessions.splice(sessionIndex, 1);

                    // Si el d√≠a original qued√≥ sin sesiones, eliminarlo
                    if (day.sessions.length === 0) {
                        dailyHistory.splice(dayIndex, 1);
                    } else {
                        // Recalcular totales del d√≠a original
                        let allPrompts = [];
                        day.sessions.forEach(s => {
                            allPrompts = allPrompts.concat(s.prompts);
                        });
                        day.totalCost = allPrompts.reduce((sum, p) => sum + p.cost, 0);
                        day.totalPrompts = allPrompts.length;
                        day.avgCostPerPrompt = day.totalCost / allPrompts.length;
                    }
                }

            } else if (type === 'completed') {
                const session = completedSessions[sessionIndex];
                updateSessionTimestamps(session, newDate);

            } else if (type === 'current') {
                // Actualizar timestamps de la sesi√≥n actual
                currentSessionPrompts.forEach((prompt, i) => {
                    const originalDate = new Date(prompt.timestamp);
                    const updatedDate = new Date(newDate);

                    if (i > 0) {
                        const prevOriginalDate = new Date(currentSessionPrompts[0].timestamp);
                        const timeDiff = originalDate - prevOriginalDate;
                        updatedDate.setTime(newDate.getTime() + timeDiff);
                    }

                    prompt.timestamp = updatedDate.toISOString();
                });
            }

            // Guardar cambios y actualizar interfaz
            saveData();
            updateAll();

            showAlert('Fecha de sesi√≥n actualizada correctamente', 'success');
        }

        function deletePrompt(index) {
            if (confirm('¬øEst√°s seguro de que quieres eliminar este prompt?')) {
                currentSessionPrompts.splice(index, 1);

                if (currentSessionPrompts.length > 0) {
                    lastUsage = currentSessionPrompts[currentSessionPrompts.length - 1].usage;
                    dailyCost = currentSessionPrompts.reduce((sum, p) => sum + p.cost, 0);
                    completedSessions.forEach(session => {
                        dailyCost += session.prompts.reduce((sum, p) => sum + p.cost, 0);
                    });
                } else {
                    lastUsage = 0;
                    dailyCost = 0;
                    completedSessions.forEach(session => {
                        dailyCost += session.prompts.reduce((sum, p) => sum + p.cost, 0);
                    });
                }

                saveData();
                updateAll();
                showAlert('Prompt eliminado correctamente', 'success');
            }
        }

        document.getElementById('promptForm').addEventListener('submit', function(e) {
            e.preventDefault();

            let inputValue = parseFloat(document.getElementById('currentUsage').value);
            const modelType = document.getElementById('modelType').value;

            if (isNaN(inputValue) || inputValue < 0 || inputValue > 100) {
                showAlert('Por favor, introduce un porcentaje v√°lido entre 0 y 100', 'danger');
                return;
            }

            // Convertir de restante a consumido si es necesario
            let currentUsage = inputValue;
            if (inputMode === 'remaining') {
                currentUsage = 100 - inputValue;
            }

            if (currentUsage < lastUsage) {
                const modeText = inputMode === 'consumed' ? 'consumido' : 'restante';
                showAlert(`El porcentaje ${modeText} no puede ser menor al anterior (${lastUsage.toFixed(2)}% consumido = ${(100 - lastUsage).toFixed(2)}% restante)`, 'warning');
                return;
            }

            const consumed = currentUsage - lastUsage;
            const cost = consumed * COST_PER_PERCENT;

            const newPrompt = {
                timestamp: new Date().toISOString(),
                usage: currentUsage,
                consumed: consumed,
                cost: cost,
                model: modelType
            };

            currentSessionPrompts.push(newPrompt);
            lastUsage = currentUsage;
            dailyCost += cost;

            saveData();
            updateAll();

            // LIMPIAR EL CAMPO DESPU√âS DE REGISTRAR
            document.getElementById('currentUsage').value = '';
            document.getElementById('currentUsage').focus();

            const displayMsg = inputMode === 'consumed'
                ? `Prompt registrado (${modelType}): ${consumed.toFixed(2)}% consumido (${cost.toFixed(3)}‚Ç¨)`
                : `Prompt registrado (${modelType}): ${consumed.toFixed(2)}% consumido = ${(100 - currentUsage).toFixed(2)}% restante (${cost.toFixed(3)}‚Ç¨)`;

            showAlert(displayMsg, 'success');
        });

        function saveData() {
            localStorage.setItem('currentSessionNumber', currentSessionNumber.toString());
            localStorage.setItem('currentSessionPrompts', JSON.stringify(currentSessionPrompts));
            localStorage.setItem('lastUsage', lastUsage.toString());
            localStorage.setItem('dailyCost', dailyCost.toString());
            localStorage.setItem('completedSessions', JSON.stringify(completedSessions));
            localStorage.setItem('dailyHistory', JSON.stringify(dailyHistory));
        }

        function resetSession() {
            if (currentSessionPrompts.length === 0) {
                showAlert('No hay datos en la sesi√≥n actual para guardar', 'warning');
                return;
            }

            if (confirm('¬øIniciar nueva sesi√≥n? Esto guardar√° la sesi√≥n actual internamente y comenzar√° una nueva sesi√≥n de 5h.')) {
                const sessionData = {
                    sessionNumber: currentSessionNumber,
                    startTime: currentSessionPrompts[0].timestamp,
                    endTime: currentSessionPrompts[currentSessionPrompts.length - 1].timestamp,
                    totalUsage: lastUsage,
                    prompts: currentSessionPrompts
                };

                completedSessions.push(sessionData);

                currentSessionNumber++;
                currentSessionPrompts = [];
                lastUsage = 0;

                saveData();
                updateAll();

                showAlert(`Sesi√≥n ${sessionData.sessionNumber} guardada. Ahora en Sesi√≥n ${currentSessionNumber}. Coste diario: ${dailyCost.toFixed(2)}‚Ç¨`, 'success');
            }
        }

        function endDay() {
            const hasCurrentSessionData = currentSessionPrompts.length > 0;
            const hasCompletedSessions = completedSessions.length > 0;

            if (!hasCurrentSessionData && !hasCompletedSessions && dailyCost === 0) {
                showAlert('No hay datos para guardar del d√≠a de hoy', 'warning');
                return;
            }

            if (confirm('¬øAcabar el d√≠a? Esto guardar√° todas las sesiones de hoy en las estad√≠sticas semanales y comenzar√° un nuevo d√≠a.')) {
                let allSessions = [...completedSessions];
                if (hasCurrentSessionData) {
                    const currentSessionData = {
                        sessionNumber: currentSessionNumber,
                        startTime: currentSessionPrompts[0].timestamp,
                        endTime: currentSessionPrompts[currentSessionPrompts.length - 1].timestamp,
                        totalUsage: lastUsage,
                        prompts: currentSessionPrompts
                    };
                    allSessions.push(currentSessionData);
                }

                let allPromptsDay = [];
                allSessions.forEach(session => {
                    allPromptsDay = allPromptsDay.concat(session.prompts);
                });

                const today = new Date().toISOString().split('T')[0];

                const dayData = {
                    date: today,
                    totalCost: dailyCost,
                    totalPrompts: allPromptsDay.length,
                    avgCostPerPrompt: allPromptsDay.length > 0 ? dailyCost / allPromptsDay.length : 0,
                    sessions: allSessions
                };

                dailyHistory.unshift(dayData);
                if (dailyHistory.length > 7) {
                    dailyHistory = dailyHistory.slice(0, 7);
                }

                currentSessionNumber = 1;
                currentSessionPrompts = [];
                lastUsage = 0;
                dailyCost = 0;
                completedSessions = [];

                saveData();
                updateAll();

                showAlert(`D√≠a finalizado. ${allSessions.length} sesiones guardadas con ${allPromptsDay.length} prompts totales. ¬°Nuevo d√≠a comenzado!`, 'success');
            }
        }

        function exportWeeklyData() {
            if (dailyHistory.length === 0) {
                showAlert('No hay datos para exportar', 'warning');
                return;
            }

            const exportData = {
                exportDate: new Date().toISOString(),
                summary: {
                    totalDays: dailyHistory.length,
                    totalCost: dailyHistory.reduce((sum, day) => sum + day.totalCost, 0),
                    totalPrompts: dailyHistory.reduce((sum, day) => sum + day.totalPrompts, 0),
                    avgDailyCost: dailyHistory.reduce((sum, day) => sum + day.totalCost, 0) / dailyHistory.length,
                    avgDailyPrompts: dailyHistory.reduce((sum, day) => sum + day.totalPrompts, 0) / dailyHistory.length
                },
                dailyData: dailyHistory
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `ai-usage-stats-${new Date().toISOString().split('T')[0]}.json`;

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            showAlert('Datos exportados correctamente en formato JSON', 'success');
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    importWeeklyData(importedData);
                } catch (error) {
                    showAlert('Error al leer el archivo JSON: ' + error.message, 'danger');
                }
            };
            reader.readAsText(file);

            // Reset the input so the same file can be imported again if needed
            event.target.value = '';
        }

        function importWeeklyData(importedData) {
            // Validar estructura del JSON
            if (!importedData || !importedData.dailyData || !Array.isArray(importedData.dailyData)) {
                showAlert('Formato de archivo inv√°lido. Aseg√∫rate de que es un archivo exportado v√°lido.', 'danger');
                return;
            }

            if (importedData.dailyData.length === 0) {
                showAlert('El archivo no contiene datos para importar.', 'warning');
                return;
            }

            // Confirmar importaci√≥n
            const confirmMsg = `¬øImportar ${importedData.dailyData.length} d√≠a(s) de datos?\n\n` +
                `Total prompts: ${importedData.summary?.totalPrompts || 'N/A'}\n` +
                `Coste total: ${importedData.summary?.totalCost?.toFixed(2) || 'N/A'}‚Ç¨\n\n` +
                `Los datos duplicados se fusionar√°n manteniendo la informaci√≥n m√°s reciente.`;

            if (!confirm(confirmMsg)) {
                return;
            }

            let mergedDays = 0;
            let addedDays = 0;
            let sessionsAdded = 0;
            let sessionsUpdated = 0;

            // Crear una copia de dailyHistory para trabajar
            let updatedHistory = [...dailyHistory];

            // Procesar cada d√≠a del archivo importado
            importedData.dailyData.forEach(importedDay => {
                // Buscar si ya existe un d√≠a con esta fecha
                const existingDayIndex = updatedHistory.findIndex(d => d.date === importedDay.date);

                if (existingDayIndex !== -1) {
                    // D√≠a ya existe - hacer merge de sesiones
                    mergedDays++;
                    const existingDay = updatedHistory[existingDayIndex];

                    // Procesar cada sesi√≥n importada
                    importedDay.sessions.forEach(importedSession => {
                        // Buscar si ya existe una sesi√≥n con el mismo n√∫mero
                        const existingSessionIndex = existingDay.sessions.findIndex(
                            s => s.sessionNumber === importedSession.sessionNumber
                        );

                        if (existingSessionIndex !== -1) {
                            // Sesi√≥n ya existe - decidir cu√°l mantener
                            const existingSession = existingDay.sessions[existingSessionIndex];

                            // Criterios de decisi√≥n (en orden de prioridad):
                            // 1. Mantener la que tenga m√°s prompts (m√°s completa)
                            // 2. Si tienen el mismo n√∫mero de prompts, mantener la m√°s reciente (por timestamp)
                            let shouldReplace = false;

                            if (importedSession.prompts.length > existingSession.prompts.length) {
                                shouldReplace = true;
                            } else if (importedSession.prompts.length === existingSession.prompts.length) {
                                // Comparar por fecha del √∫ltimo prompt
                                const importedLastTimestamp = new Date(importedSession.prompts[importedSession.prompts.length - 1].timestamp);
                                const existingLastTimestamp = new Date(existingSession.prompts[existingSession.prompts.length - 1].timestamp);

                                if (importedLastTimestamp > existingLastTimestamp) {
                                    shouldReplace = true;
                                }
                            }

                            if (shouldReplace) {
                                existingDay.sessions[existingSessionIndex] = importedSession;
                                sessionsUpdated++;
                            }
                        } else {
                            // Sesi√≥n nueva - agregar
                            existingDay.sessions.push(importedSession);
                            sessionsAdded++;
                        }
                    });

                    // Recalcular totales del d√≠a despu√©s del merge
                    let allPrompts = [];
                    existingDay.sessions.forEach(s => {
                        allPrompts = allPrompts.concat(s.prompts);
                    });
                    existingDay.totalCost = allPrompts.reduce((sum, p) => sum + p.cost, 0);
                    existingDay.totalPrompts = allPrompts.length;
                    existingDay.avgCostPerPrompt = allPrompts.length > 0 ? existingDay.totalCost / allPrompts.length : 0;

                } else {
                    // D√≠a nuevo - agregar completo
                    updatedHistory.push(importedDay);
                    addedDays++;
                    sessionsAdded += importedDay.sessions.length;
                }
            });

            // Ordenar por fecha (m√°s reciente primero)
            updatedHistory.sort((a, b) => new Date(b.date) - new Date(a.date));

            // Mantener solo los √∫ltimos 7 d√≠as
            if (updatedHistory.length > 7) {
                updatedHistory = updatedHistory.slice(0, 7);
            }

            // Actualizar dailyHistory
            dailyHistory = updatedHistory;

            // Guardar y actualizar interfaz
            saveData();
            updateAll();

            // Mostrar resumen de la importaci√≥n
            let summaryMsg = '‚úÖ Datos importados correctamente:\n\n';
            if (addedDays > 0) summaryMsg += `‚Ä¢ ${addedDays} d√≠a(s) nuevos agregados\n`;
            if (mergedDays > 0) summaryMsg += `‚Ä¢ ${mergedDays} d√≠a(s) fusionados con datos existentes\n`;
            if (sessionsAdded > 0) summaryMsg += `‚Ä¢ ${sessionsAdded} sesi√≥n(es) nuevas agregadas\n`;
            if (sessionsUpdated > 0) summaryMsg += `‚Ä¢ ${sessionsUpdated} sesi√≥n(es) actualizadas con datos m√°s recientes\n`;
            summaryMsg += `\nüìä Total en historial: ${dailyHistory.length} d√≠a(s)`;

            showAlert(summaryMsg, 'success');
        }

        function updateAll() {
            updateDashboard();
            updateHistoryTable();
            updateTodayStats();
            updateWeeklyStats();
            updateEditDatesSection();
        }

        // Inicializar la aplicaci√≥n
        updateInputModeUI(); // Establecer el modo de entrada correcto al cargar
        updateAll();
    </script>
</body>
</html>
